
<!DOCTYPE html>
<html>
<head>
  <title></title>
    <link href="https://fonts.googleapis.com/css?family=Kumar+One" rel="stylesheet">
</head>
<style type="text/css">
html,
body {
    margin: 0;
    height: 100%;
}
/* Scale canvas with resize attribute to full size */
canvas[resize] {

    width: 100%;
    height: 100%;
    //background-color : white;
}


div.container{
  width: 100%;
  //border: 1px solid gray;
}

header, footer{
  width: 100%;
  padding: 1em;
  color: white;
  background-color: purple;
  clear: left;
  text-align: center;
}

nav{
  float: left;
  max-width: 160px;
  margin: 0;
  padding: 1em;
}

nav ul{
  list-style-type: none;
  padding: 0;
}

nav ul a{
  text-decoration: none;
}

article {
  margin-left: 170px;
  border-left: 1px solid gray;
  padding: 1em;
  overflow: hidden;
}

/*#article {
  margin-left: 170px;
  border-left: 1px solid gray;
  padding: 10em;
  overflow: hidden;
}*/


</style>
<script type = "text/javascript" src = "http://paperjs.org/assets/js/paper.js"> </script>
</head>

<body>
<!-- hello, world! -->
<canvas id="canvas-1" hidpi="on" resize = "true" ></canvas>
</body>

<script type= "text/paperscript" canvas = "canvas-1" >
var bgR;
var bgG;
var bgB;
var randomColor;

var background = new Path.Rectangle({
    point: [0, 0],
    size: [view.size.width, view.size.height],
    strokeColor: 'white'
});
background.sendToBack();

var MyCharacterClass = function(){
  this.airPollution = 0;
  this.airPollution2 = 0;

  this.text = new PointText({
    point:[10,130],
    content:"",
    fontSize: 160
  });

  this.albumen = new Path({
         segments: [[30,40], [150,0], [220,0], [300,70], [320,120], [300,180], [280,240], [200,300], [60,290], [30,250], [-20,180], [0,130]],
         closed: true
     });

  this.albumen.style = {
       fillColor: '#fcfcfc',
       strokeColor: '#efefef',
       strokeWidth: 5
     };

  this.albumen.smooth({
       type: 'catmull-rom',
       factor: 0.4
     });

     this.vitellus = new Shape.Circle([150,150], 76);
     this.vitellus.style = {
       fillColor: '#ffd500',
       strokeWidth: 5
     };


     /* 눈 */
     this.sclera = new Shape.Ellipse({
       center: [0, 0],
       radius: [30, 38],
       fillColor: 'white',
       strokeColor: '#efe3e8',
       strokeWidth: 4
     });

     this.iris = new Shape.Circle({
       center: [10, 0],
       radius: 15,
       fillColor: '#661fb4',
       strokeColor: '#220a3c',
       strokeWidth: 4
     });

     this.pupil = new Shape.Circle({
       center: [10, 0],
       radius: 9,
       fillColor: '#220a3c',
     });

     this.highlight = new Shape.Circle({
       center: [15, -8],
       radius: 3,
       fillColor: 'white'
     });

     this.eye = new Group([this.sclera, this.iris, this.pupil, this.highlight]);
     this.eye.position = [143,150];

     this.eye_l = this.eye.clone();
     this.eye.position.x += 50;



     /* 팔 */
     this.arm_origin = new Point(15, 0);
     this.arm_joint = new Point(25, 70);
     this.arm_end = new Point(0, 140);

     this.arm_path = new Path({
         segments: [this.arm_origin, this.arm_joint, this.arm_end],
         closed: false,
         strokeColor: '#222',
         strokeWidth: 20,
     });

     this.arm_path.smooth({
       type: 'continuous'
     });
     this.arm_path.strokeCap = 'round';

     this.arm = new Group([this.arm_path]);
     this.arm.position.y =+ 250;
     this.arm_l = this.arm.clone();
     this.arm_l.position.x -= 20;
     this.arm_l.children[0].pivot = this.arm_l.children[0].segments[0].point;
     this.arm_l.rotate(20);
     this.arm_r = this.arm.clone();
     this.arm_r.position.x += 310;
     this.arm_r.children[0].pivot = this.arm_r.children[0].segments[0].point;
     this.arm_r.position.y -= 80;
     this.arm_r.rotate(50);
     this.arm.visible = false;
     this.eyebrow_l = new Path({
       segments:[[185, 113], [230, 133]],
       closed: false,
       strokeColor: 'black',
       strokeWidth: 10
     });
     this.eyebrow_r = new Path({
       segments:[[115, 133], [160, 113]],
       closed: false,
       strokeColor: 'black',
       strokeWidth: 10
     });

     this.eyebrow = new Group([this.eyebrow_r, this.eyebrow_l]);
     this.eyebrow_r.visible = false;
     this.eyebrow_l.visible = false;

     /* 다리 */
     this.leg_origin = new Point(0, 0);
     this.leg_joint = new Point(10, 40);
     this.leg_end = new Point(0, 80);

     this.socksColor = new Gradient({
         stops: [['#222', 0.15], ['white', 0.15], ['white', 0.25], ['#661fb4', 0.25],
         ['#661fb4', 0.35], ['white', 0.35], ['white', 0.4], ['#661fb4', 0.4], ['#661fb4', 0.5],['white', 0.5]],
         origin: this.leg_joint,
         destination: this.leg_end
     });
     this.socks = new Color(this.socksColor, this.leg_joint, this.leg_end);

     this.leg_path = new Path(this.leg_origin, this.leg_joint, this.leg_end);
     this.leg_path.strokeColor = this.socks;
     this.leg_path.strokeWidth = 25;
     this.leg_path.smooth({
       type: 'continuous'
     });

     this.shoes = new Path({
       segments : [[0,5], [30,5], [25,17], [50,17], [55,35], [0,35]],
       closed: true,

       fillColor: '#692c21',
       strokeColor: '#56241b',
       strokeWidth: 3
     });

     this.shoes.smooth({
         type: 'continuous',
         from: 2,
         to: 4
     });
     this.shoes.rotate(20);
     this.shoes.position.x -= 15;
     this.shoes.position.y += 70;
     this.leg = new Group([this.leg_path, this.shoes]);
     this.leg.position.x =+ 150;
     this.leg.position.y =+ 350;

     this.leg_l = this.leg.clone();
     this.leg_l.position.x -= 40;
     this.leg_l.position.y -= 5;

     this.leg_r = this.leg.clone();
     this.leg_r.position.x += 60;
     this.leg_r.rotate(-20);

     this.leg.visible = false;



     this.smile = new Path({
       segments : [[130, 180],[175, 200], [220, 180]],
       closed : false,
       strokeColor: 'black',
       strokeWidth: 10
     });

     this.smile.smooth({
         type: 'continuous'
       });
    this.smile.visible = false;

     this.egg_body = new Group ([this.albumen, this.vitellus]);
    //this.eye = new Group([this.sclera, this.iris, this.pupil, this.highlight]);
     this.eyes = new Group([this.eye, this.eye_l, this.eyebrow_r, this.eyebrow_l, this.smile]);
     //this.arm = new Group([this.arm_path]);
     this.arms = new Group([this.arm_l, this.arm_r]);
     //this.leg_path = new Path(this.leg_origin, this.leg_joint, this.leg_end);
     //this.leg = new Group([this.leg_path, this.shoes]);
     this.legs = new Group([this.leg_l, this.leg_r]);
     this.character = new Group([this.legs, this.arms, this.egg_body, this.eyes]);

     this.character.applyMatrix = false;
     this.character.scale(0.7);

     this.character.applyMatrix = false;

     this.sad = function(){
       this.eyebrow.visible = true;
       //arms
       this.arm_l.strokeColor = '#ffd500';
       this.arm_r.strokeColor = '#ffd500';


       //legs
       this.leg_l.strokeColor = 'black';
       this.leg_r.strokeColor = 'black';

       //shoes
       this.shoes.style = {
         strokeColor : "black",
         fillColor : "black"
       };

       //face
       this.albumen.style = {
         strokeColor : "black",
         fillColor : "black"
       };

       //eyes
       this.pupil.style = {
         strokeColor : "black",
         strokeWidth : 3,
         fillColor : "black"
       };

       this.pupil.style = {
         strokeColor : "black",
         strokeWidth : 3,
         fillColor : "black"
       };
     this.eyebrow_r.visible = true;
     this.eyebrow_l.visible = true;
     }

     this.happy = function() {

       randomColor = new Color(Math.random(),Math.random(),Math.random());
       this.albumen.fillColor = randomColor;
       this.albumen.strokeColor=randomColor;

       this.smile.visible = true;

       this.arm_l.strokeColor = '#222';
       this.arm_r.strokeColor = '#222';
    }

    this.normal = function(){
      this.smile.visible = false;
      this.eyebrow.visible = false;

      this.albumen.style = {
           fillColor: '#fcfcfc',
           strokeColor: '#efefef',
           strokeWidth: 5
         };

      this.albumen.smooth({
           type: 'catmull-rom',
           factor: 0.4
         });

       this.vitellus.style = {
         fillColor: '#ffd500',
         strokeWidth: 5
       };
    }

    this.changeText = function(forContent){
      this.text.content = forContent;
    }
}

  var mouse = new MyCharacterClass();
  mouse.arms.visible = false;
  mouse.legs.visible = false;
  mouse.character.scale(0.2);


  function onMouseMove(event) {
    mouse.character.position = event.point;
  }

var family = new MyCharacterClass();
family.character.position = view.center;

var changingVolume;

var webaudio_tooling_obj = function () {

      var audioContext = new AudioContext();
      console.log("audio is starting up ...");
      var BUFF_SIZE = 16384;
      var audioInput = null,
          microphone_stream = null,
          gain_node = null,
          script_processor_node = null,
          script_processor_fft_node = null,
          analyserNode = null;

      if (!navigator.getUserMedia)
              navigator.getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia ||
                            navigator.mozGetUserMedia || navigator.msGetUserMedia;

      if (navigator.getUserMedia){

          navigator.getUserMedia({audio:true},
            function(stream) {
                start_microphone(stream);

            },
            function(e) {
              alert('Error capturing audio.');
            }
          );

      } else { alert('getUserMedia not supported in this browser.'); }

      // ---





      function show_some_data(given_typed_array, num_row_to_display, label) {

          var size_buffer = given_typed_array.length;
          var index = 0;
          var max_index = num_row_to_display;
          var sum = 0;
          //console.log("__________ " + label);

          for (; index < max_index && index < size_buffer; index += 1) {

              //console.log(given_typed_array[index]);
              sum += given_typed_array[index];
          }
          //console.log("sum = " + sum);
          changingVolume = sum/num_row_to_display;
          console.log("changingVolume = " + changingVolume);
          family.changeText(changingVolume.toString());

          bgR = map(changingVolume, 0, 100, 1, 0.4);
          bgG = map(changingVolume, 0, 100, 1, 0);
          bgB = map(changingVolume, 0, 100, 1, 0.4);

          background.fillColor = new Color(bgR, bgG, bgB);
          if(changingVolume > 30) {
            family.happy();
          }
          else {
            family.normal();
          }

      }




      function process_microphone_buffer(event) {

          var i, N, inp, microphone_output_buffer;

          microphone_output_buffer = event.inputBuffer.getChannelData(0); // just mono - 1 channel for now

          // microphone_output_buffer  <-- this buffer contains current gulp of data size BUFF_SIZE

          show_some_data(microphone_output_buffer, 5, "from getChannelData");
      }





      function start_microphone(stream)
      {

            gain_node = audioContext.createGain();
            gain_node.connect( audioContext.destination );

            microphone_stream = audioContext.createMediaStreamSource(stream);
            microphone_stream.connect(gain_node);

            script_processor_node = audioContext.createScriptProcessor(BUFF_SIZE, 1, 1);
            script_processor_node.onaudioprocess = process_microphone_buffer;

            microphone_stream.connect(script_processor_node);

            script_processor_fft_node = audioContext.createScriptProcessor(2048, 1, 1);
            script_processor_fft_node.connect(gain_node);

            analyserNode = audioContext.createAnalyser();
            analyserNode.smoothingTimeConstant = 0;
            analyserNode.fftSize = 2048;

            microphone_stream.connect(analyserNode);
            gain_node.gain.value = 0;
            analyserNode.connect(script_processor_fft_node);

            script_processor_fft_node.onaudioprocess = function()
            {

              // get the average for the first channel
              var array = new Uint8Array(analyserNode.frequencyBinCount);
              analyserNode.getByteFrequencyData(array);

              // draw the spectrogram
              if (microphone_stream.playbackState == microphone_stream.PLAYING_STATE) {

                  show_some_data(array, 5, "from fft");
              }
            };
      }

}();
function map(value, start1, stop1, start2, stop2) {
    return start2 + (stop2 - start2) * ((value - start1) / (stop1 - start1));
}

</script>


</html>
